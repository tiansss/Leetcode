# 78. Subsets
[https://leetcode.com/problems/subsets/description/](https://leetcode.com/problems/subsets/description/)

## Key
* 用递归，但有一些tricks，看注释

## Code
```
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    public void findSet(int[] nums, List<Integer> list, int index, int cur){
        //index表示现在打算添加的是第几位，cur表示上一位取到的值在nums中的下标
        ans.add(list);//每来一个list都存到ans中
        if (index != 0 && nums[cur] == nums[nums.length-1]) return;//如果上一位添加的已经是nums中最后一个值了那就不用再往下生成了
        
        for (int i = cur+1; i < nums.length; i++){//下一位取值范围应该是上一位下标+1一直到最后
            List<Integer> list0 = new ArrayList<>();//这里有个超级恶心的，如果只用原来的list添加新的值传到下一轮的话，在ans中添加的就全都是指向同一个list，这样ans中就都是一样的值，所以每次要新生成一个list0，并且把上一轮list中的值放进去，然后再添加这一轮新生成的nums[i]
            for (int x: list){
                list0.add(x);
            }
            list0.add(nums[i]);
            index++;//表示开始看下一位，不能在findSet中index++,因为++是后做的。。。
            findSet(nums, list0, index, i);
            index--; //一定不要忘了复原index！！！！！递归回来之后又回到了这一位
        }
    }
    public List<List<Integer>> subsets(int[] nums) {     
        List<Integer> list = new ArrayList<>();
          findSet(nums, list, 0, -1);
        return ans;
    }
}
```
